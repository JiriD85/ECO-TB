// ============================================================
// Normalize Data - TBEL Script
// Transforms CHC_* keys to canonical names, checks data quality,
// and calculates derived telemetry (is_on, load_class, dT_flag)
//
// Used in: RESI Device Rule Chain > "Normalize Data" Node
// ROBUST: Handles missing data points and attributes gracefully
// ============================================================

var newValues = {};
var dataQuality = "ok";

// Safely get values - could be nested or flat structure
var values = msg;
if (msg["values"] != null) {
    values = msg["values"];
}

// ============================================================
// Get Attributes from Metadata (fetched by previous node)
// All attributes are optional - use defaults if missing
// ============================================================

var installationType = "heating";
if (metadata["ss_installationType"] != null) {
    installationType = metadata["ss_installationType"];
}

// flowOnThreshold in m³/h (default: 0.05) - metadata values are strings!
var flowOnThreshold = 0.05;
if (metadata["ss_flowOnThreshold"] != null && metadata["ss_flowOnThreshold"] != "") {
    flowOnThreshold = parseDouble(metadata["ss_flowOnThreshold"]);
}

// designPower in kW (optional - needed for load_class) - metadata values are strings!
var designPower = null;
if (metadata["ss_designPower"] != null && metadata["ss_designPower"] != "") {
    designPower = parseDouble(metadata["ss_designPower"]);
}

// designDeltaT in K (optional - needed for dT_flag) - metadata values are strings!
var designDeltaT = null;
if (metadata["ss_designDeltaT"] != null && metadata["ss_designDeltaT"] != "") {
    designDeltaT = parseDouble(metadata["ss_designDeltaT"]);
}

// deviceName for TS1/TS2 detection
var deviceName = "";
if (metadata["deviceName"] != null) {
    deviceName = metadata["deviceName"];
}

// calculatePower - enable power calculation from cp * m * dT
var calculatePower = false;
if (metadata["ss_calculatePower"] != null && metadata["ss_calculatePower"] == "true") {
    calculatePower = true;
}

// fluidType for cp/rho values (water, glycol20, glycol30)
var fluidType = "water";
if (metadata["ss_fluidType"] != null && metadata["ss_fluidType"] != "") {
    fluidType = metadata["ss_fluidType"];
}

// ============================================================
// Absolute limits for outlier detection
// ============================================================
var MAX_POWER_KW = 10000;
var MAX_ENERGY_KWH = 100000;
var MIN_TEMP_C = -50;
var MAX_TEMP_C = 200;
var MAX_FLOW_M3H = 1000;

// ============================================================
// Key Mapping: CHC_* → Canonical Names
// ============================================================

// --- Temperature keys ---
if (values["CHC_S_TemperatureFlow"] != null) {
    newValues["T_flow_C"] = values["CHC_S_TemperatureFlow"];
}
if (values["CHC_S_TemperatureReturn"] != null) {
    newValues["T_return_C"] = values["CHC_S_TemperatureReturn"];
}

// Calculate dT_K: prefer existing value, otherwise calculate from T_flow - T_return
// Use absolute value for cooling (T_return > T_flow)
if (values["CHC_S_TemperatureDiff"] != null) {
    var rawDT = values["CHC_S_TemperatureDiff"];
    newValues["dT_K"] = Math.abs(rawDT);
} else if (newValues["T_flow_C"] != null && newValues["T_return_C"] != null) {
    var dT = newValues["T_flow_C"] - newValues["T_return_C"];
    newValues["dT_K"] = Math.abs(Math.round(dT * 1000) / 1000);
}

// --- Flow keys ---
// VolumeFlow comes in l/h, convert to m³/h (divide by 1000)
if (values["CHC_S_VolumeFlow"] != null) {
    newValues["Vdot_m3h"] = values["CHC_S_VolumeFlow"] / 1000;
}
if (values["CHC_S_Velocity"] != null) {
    newValues["v_ms"] = values["CHC_S_Velocity"];
}

// --- Power: select based on installationType ---
if (installationType == "cooling") {
    if (values["CHC_S_Power_Cooling"] != null) {
        newValues["P_th_kW"] = values["CHC_S_Power_Cooling"];
    }
} else {
    if (values["CHC_S_Power_Heating"] != null) {
        newValues["P_th_kW"] = values["CHC_S_Power_Heating"];
    }
}

// --- Energy meter: select based on installationType ---
if (installationType == "cooling") {
    if (values["CHC_M_Energy_Cooling"] != null) {
        newValues["E_th_kWh"] = values["CHC_M_Energy_Cooling"];
    }
} else {
    if (values["CHC_M_Energy_Heating"] != null) {
        newValues["E_th_kWh"] = values["CHC_M_Energy_Heating"];
    }
}

// --- Volume meter ---
if (values["CHC_M_Volume"] != null) {
    newValues["V_m3"] = values["CHC_M_Volume"];
}

// --- Auxiliary temperature sensors (TS1/TS2 devices) ---
if (values["temperature"] != null) {
    if (deviceName.endsWith("_TS1")) {
        newValues["auxT1_C"] = values["temperature"];
    } else if (deviceName.endsWith("_TS2")) {
        newValues["auxT2_C"] = values["temperature"];
    } else {
        newValues["temperature"] = values["temperature"];
    }
}

// ============================================================
// Calculated Power: P = rho * cp * Vdot * dT
// ============================================================
if (calculatePower && newValues["Vdot_m3h"] != null && newValues["dT_K"] != null) {

    // Get reference temperature for density calculation (use T_flow, default 40°C)
    var refTemp = 40.0;
    if (newValues["T_flow_C"] != null) {
        refTemp = newValues["T_flow_C"];
    }

    // Calculate fluid properties based on fluidType
    // cp [kJ/(kg·K)], rho [kg/m³]
    var cp = 4.186;
    var rho = 1000.0;

    if (fluidType == "water") {
        // Water: cp nearly constant, rho temperature-dependent
        // rho(T) = 1000 - 0.4 * (T - 20) for T in °C
        cp = 4.186;
        rho = 1000.0 - 0.4 * (refTemp - 20.0);
        // Clamp rho to reasonable range
        if (rho < 950) { rho = 950; }
        if (rho > 1000) { rho = 1000; }
    } else if (fluidType == "glycol20") {
        // 20% Ethylene Glycol - fixed values at ~20°C
        cp = 3.87;
        rho = 1025.0;
    } else if (fluidType == "glycol30") {
        // 30% Ethylene Glycol - fixed values at ~20°C
        cp = 3.65;
        rho = 1040.0;
    } else if (fluidType == "glycol40") {
        // 40% Ethylene Glycol - fixed values at ~20°C
        cp = 3.45;
        rho = 1055.0;
    } else if (fluidType == "propyleneGlycol20") {
        // 20% Propylene Glycol - fixed values at ~20°C
        cp = 3.95;
        rho = 1020.0;
    } else if (fluidType == "propyleneGlycol30") {
        // 30% Propylene Glycol - fixed values at ~20°C
        cp = 3.75;
        rho = 1030.0;
    }

    // P [kW] = rho [kg/m³] * cp [kJ/(kg·K)] * Vdot [m³/h] * dT [K] / 3600 [s/h]
    // Simplified: P = (rho * cp / 3600) * Vdot * dT
    var factor = (rho * cp) / 3600.0;
    var P_calc = factor * newValues["Vdot_m3h"] * newValues["dT_K"];
    newValues["P_th_calc_kW"] = Math.round(P_calc * 1000) / 1000;

    // ============================================================
    // Power Deviation Detection (compare measured vs calculated)
    // ============================================================
    if (newValues["P_th_kW"] != null && newValues["P_th_calc_kW"] > 0) {
        // Calculate deviation percentage
        var deviation = ((newValues["P_th_kW"] - newValues["P_th_calc_kW"]) / newValues["P_th_calc_kW"]) * 100;
        newValues["P_deviation_pct"] = Math.round(deviation * 10) / 10;

        // Set P_sensor_flag based on absolute deviation
        var absDeviation = Math.abs(deviation);
        if (absDeviation < 10) {
            newValues["P_sensor_flag"] = "ok";
        } else if (absDeviation < 25) {
            newValues["P_sensor_flag"] = "warn";
        } else {
            newValues["P_sensor_flag"] = "error";
        }
    }
}

// ============================================================
// Derived Telemetry
// ============================================================

// --- is_on: System running if flow > threshold ---
if (newValues["Vdot_m3h"] != null) {
    newValues["is_on"] = newValues["Vdot_m3h"] > flowOnThreshold;
}

// --- load_class: low/mid/high based on power vs design ---
var loadClass = null;
if (newValues["P_th_kW"] != null && designPower != null && designPower > 0) {
    var loadPct = (newValues["P_th_kW"] / designPower) * 100;
    if (loadPct < 30) {
        loadClass = "low";
    } else if (loadPct < 60) {
        loadClass = "mid";
    } else {
        loadClass = "high";
    }
    newValues["load_class"] = loadClass;
}

// --- dT_flag: ok/warn/severe based on actual vs design delta-T ---
// Only evaluate at mid/high load (skip low load)
if (newValues["dT_K"] != null && designDeltaT != null && designDeltaT > 0) {
    // Only calculate if load_class is mid or high (or if we don't have load_class)
    var shouldEvaluate = (loadClass == null) || (loadClass == "mid") || (loadClass == "high");

    if (shouldEvaluate) {
        var dTRatio = newValues["dT_K"] / designDeltaT;
        if (dTRatio >= 0.8) {
            newValues["dT_flag"] = "ok";
        } else if (dTRatio >= 0.6) {
            newValues["dT_flag"] = "warn";
        } else {
            newValues["dT_flag"] = "severe";
        }
    }
}

// --- schedule_violation: running outside defined operating hours ---
if (metadata["ss_weeklySchedule"] != null && metadata["ss_weeklySchedule"] != "") {

    var schedule = JSON.parse(metadata["ss_weeklySchedule"]);

    // Timezone offset in minutes (default: 60 = CET, this is the WINTER time offset)
    var tzOffset = 60;
    if (schedule["timezoneOffset"] != null) {
        tzOffset = schedule["timezoneOffset"];
    }

    // Get timestamp
    var ts = msg["ts"];
    if (ts == null && metadata["ts"] != null) {
        ts = parseLong(metadata["ts"]);
    }

    if (ts != null && newValues["is_on"] != null) {

        // ============================================================
        // European DST Detection (CET/CEST)
        // DST starts: last Sunday of March at 02:00 UTC
        // DST ends: last Sunday of October at 03:00 UTC
        // ============================================================
        var isDST = false;

        // Calculate year, month, day from UTC timestamp
        var msPerDay = 86400000;
        var days = Math.floor(ts / msPerDay);

        // Days since 1970-01-01 (Thursday) to get year/month/day
        // Using algorithm to extract date components
        var z = days + 719468;
        var era = Math.floor((z >= 0 ? z : z - 146096) / 146097);
        var doe = z - era * 146097;
        var yoe = Math.floor((doe - Math.floor(doe / 1460) + Math.floor(doe / 36524) - Math.floor(doe / 146096)) / 365);
        var year = yoe + era * 400;
        var doy = doe - (365 * yoe + Math.floor(yoe / 4) - Math.floor(yoe / 100));
        var mp = Math.floor((5 * doy + 2) / 153);
        var day = doy - Math.floor((153 * mp + 2) / 5) + 1;
        var month = mp + (mp < 10 ? 3 : -9);
        if (month <= 2) { year = year + 1; }

        // April to September: definitely DST
        if (month > 3 && month < 10) {
            isDST = true;
        }
        // November to February: definitely not DST
        else if (month < 3 || month > 10) {
            isDST = false;
        }
        // March or October: need to check exact date
        else {
            // Find last Sunday of the month
            // Days in month: March=31, October=31
            var daysInMonth = 31;
            // Day of week for 1st of month (0=Sun, 1=Mon, ...)
            // Calculate days from epoch to 1st of month
            var y = year;
            var m = month;
            if (m <= 2) { y = y - 1; m = m + 12; }
            var firstOfMonth = 365 * y + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) + Math.floor((153 * (m - 3) + 2) / 5) + 1 - 719469;
            var dowFirst = (firstOfMonth + 4) % 7; // 0=Sun

            // Last Sunday = last day - (day_of_week_of_last_day)
            var dowLast = (dowFirst + daysInMonth - 1) % 7;
            var lastSunday = daysInMonth - dowLast;
            if (dowLast == 0) { lastSunday = daysInMonth; } // If last day is Sunday

            if (month == 3) {
                // March: DST starts at 02:00 UTC on last Sunday
                // After last Sunday = DST
                if (day > lastSunday) {
                    isDST = true;
                } else if (day == lastSunday) {
                    // Check if after 02:00 UTC
                    var hourUTC = Math.floor((ts % msPerDay) / 3600000);
                    isDST = (hourUTC >= 2);
                }
            } else {
                // October: DST ends at 03:00 UTC on last Sunday
                // Before last Sunday = DST
                if (day < lastSunday) {
                    isDST = true;
                } else if (day == lastSunday) {
                    // Check if before 03:00 UTC
                    var hourUTC = Math.floor((ts % msPerDay) / 3600000);
                    isDST = (hourUTC < 3);
                }
            }
        }

        // Apply DST correction: add 60 minutes in summer
        var effectiveOffset = isDST ? tzOffset + 60 : tzOffset;

        // Convert to local time (add effective timezone offset)
        var localTs = ts + effectiveOffset * 60000;

        // Day of week from local timestamp (0=Sun, 1=Mon, ... 6=Sat)
        // Unix epoch (1970-01-01) was a Thursday (day 4)
        var dayIndex = (Math.floor(localTs / 86400000) + 4) % 7;
        var dayNames = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
        var dayName = dayNames[dayIndex];

        // Current local time as minutes since midnight
        var msInDay = localTs % 86400000;
        var currentMinutes = Math.floor(msInDay / 60000);

        // Get today's schedule
        var today = schedule[dayName];
        var isWithinSchedule = false;

        if (today != null && today["enabled"] == true) {
            // Parse start "HH:MM" → minutes since midnight
            var startStr = today["start"];
            var startMinutes = parseLong(startStr.substring(0, 2)) * 60 + parseLong(startStr.substring(3, 5));

            // Parse end "HH:MM" → minutes since midnight
            var endStr = today["end"];
            var endMinutes = parseLong(endStr.substring(0, 2)) * 60 + parseLong(endStr.substring(3, 5));

            // Check if current time is within schedule
            if (currentMinutes >= startMinutes && currentMinutes <= endMinutes) {
                isWithinSchedule = true;
            }
        }

        // Violation = system running outside scheduled operating hours
        newValues["schedule_violation"] = (newValues["is_on"] == true && !isWithinSchedule);
    }
}

// ============================================================
// Outlier Detection (only check if value exists)
// ============================================================

// Check Power
if (newValues["P_th_kW"] != null) {
    if (newValues["P_th_kW"] < 0 || newValues["P_th_kW"] > MAX_POWER_KW) {
        dataQuality = "error";
    }
}

// Check Calculated Power
if (newValues["P_th_calc_kW"] != null) {
    if (newValues["P_th_calc_kW"] < 0 || newValues["P_th_calc_kW"] > MAX_POWER_KW) {
        dataQuality = "error";
    }
}

// Check Energy (meter value should be positive)
if (newValues["E_th_kWh"] != null) {
    if (newValues["E_th_kWh"] < 0 || newValues["E_th_kWh"] > MAX_ENERGY_KWH) {
        dataQuality = "error";
    }
}

// Check Temperatures
if (newValues["T_flow_C"] != null) {
    if (newValues["T_flow_C"] < MIN_TEMP_C || newValues["T_flow_C"] > MAX_TEMP_C) {
        dataQuality = "error";
    }
}
if (newValues["T_return_C"] != null) {
    if (newValues["T_return_C"] < MIN_TEMP_C || newValues["T_return_C"] > MAX_TEMP_C) {
        dataQuality = "error";
    }
}
if (newValues["auxT1_C"] != null) {
    if (newValues["auxT1_C"] < MIN_TEMP_C || newValues["auxT1_C"] > MAX_TEMP_C) {
        dataQuality = "error";
    }
}
if (newValues["auxT2_C"] != null) {
    if (newValues["auxT2_C"] < MIN_TEMP_C || newValues["auxT2_C"] > MAX_TEMP_C) {
        dataQuality = "error";
    }
}

// Check Flow
if (newValues["Vdot_m3h"] != null) {
    if (newValues["Vdot_m3h"] < 0 || newValues["Vdot_m3h"] > MAX_FLOW_M3H) {
        dataQuality = "error";
    }
}

// ============================================================
// Set data_quality flag
// ============================================================
newValues["data_quality"] = dataQuality;

// ============================================================
// Build output message
// ============================================================
var newMsg = {};

// Preserve timestamp if present
if (msg["ts"] != null) {
    newMsg["ts"] = msg["ts"];
}

// Only output if we have at least one value (besides data_quality)
if (newValues.size() > 1) {
    newMsg["values"] = newValues;
    return {msg: newMsg, metadata: metadata, msgType: msgType};
} else {
    return {msg: {}, metadata: metadata, msgType: msgType};
}
