// ============================================================
// Normalize Data - TBEL Script
// Transforms CHC_* keys to canonical names, checks data quality,
// and calculates derived telemetry (is_on, load_class, dT_flag)
//
// Used in: RESI Device Rule Chain > "Normalize Data" Node
// ROBUST: Handles missing data points and attributes gracefully
// ============================================================

var newValues = {};
var dataQuality = "ok";

// Safely get values - could be nested or flat structure
var values = msg;
if (msg["values"] != null) {
    values = msg["values"];
}

// ============================================================
// Get Attributes from Metadata (fetched by previous node)
// All attributes are optional - use defaults if missing
// ============================================================

var installationType = "heating";
if (metadata["ss_installationType"] != null) {
    installationType = metadata["ss_installationType"];
}

// flowOnThreshold in m³/h (default: 0.05) - metadata values are strings!
var flowOnThreshold = 0.05;
if (metadata["ss_flowOnThreshold"] != null && metadata["ss_flowOnThreshold"] != "") {
    flowOnThreshold = parseDouble(metadata["ss_flowOnThreshold"]);
}

// designPower in kW (optional - needed for load_class) - metadata values are strings!
var designPower = null;
if (metadata["ss_designPower"] != null && metadata["ss_designPower"] != "") {
    designPower = parseDouble(metadata["ss_designPower"]);
}

// designDeltaT in K (optional - needed for dT_flag) - metadata values are strings!
var designDeltaT = null;
if (metadata["ss_designDeltaT"] != null && metadata["ss_designDeltaT"] != "") {
    designDeltaT = parseDouble(metadata["ss_designDeltaT"]);
}

// deviceName for TS1/TS2 detection
var deviceName = "";
if (metadata["deviceName"] != null) {
    deviceName = metadata["deviceName"];
}

// calculatePower - enable power calculation from cp * m * dT
var calculatePower = false;
if (metadata["ss_calculatePower"] != null && metadata["ss_calculatePower"] == "true") {
    calculatePower = true;
}

// fluidType for cp/rho values (water, glycol20, glycol30)
var fluidType = "water";
if (metadata["ss_fluidType"] != null && metadata["ss_fluidType"] != "") {
    fluidType = metadata["ss_fluidType"];
}

// ============================================================
// Absolute limits for outlier detection
// ============================================================
var MAX_POWER_KW = 10000;
var MAX_ENERGY_KWH = 100000;
var MIN_TEMP_C = -50;
var MAX_TEMP_C = 200;
var MAX_FLOW_M3H = 1000;

// ============================================================
// Key Mapping: CHC_* → Canonical Names
// ============================================================

// --- Temperature keys ---
if (values["CHC_S_TemperatureFlow"] != null) {
    newValues["T_flow_C"] = values["CHC_S_TemperatureFlow"];
}
if (values["CHC_S_TemperatureReturn"] != null) {
    newValues["T_return_C"] = values["CHC_S_TemperatureReturn"];
}

// Calculate dT_K: prefer existing value, otherwise calculate from T_flow - T_return
// Use absolute value for cooling (T_return > T_flow)
if (values["CHC_S_TemperatureDiff"] != null) {
    var rawDT = values["CHC_S_TemperatureDiff"];
    newValues["dT_K"] = Math.abs(rawDT);
} else if (newValues["T_flow_C"] != null && newValues["T_return_C"] != null) {
    var dT = newValues["T_flow_C"] - newValues["T_return_C"];
    newValues["dT_K"] = Math.abs(Math.round(dT * 1000) / 1000);
}

// --- Flow keys ---
// VolumeFlow comes in l/h, convert to m³/h (divide by 1000)
if (values["CHC_S_VolumeFlow"] != null) {
    newValues["Vdot_m3h"] = values["CHC_S_VolumeFlow"] / 1000;
}
if (values["CHC_S_Velocity"] != null) {
    newValues["v_ms"] = values["CHC_S_Velocity"];
}

// --- Power: select based on installationType ---
if (installationType == "cooling") {
    if (values["CHC_S_Power_Cooling"] != null) {
        newValues["P_th_kW"] = values["CHC_S_Power_Cooling"];
    }
} else {
    if (values["CHC_S_Power_Heating"] != null) {
        newValues["P_th_kW"] = values["CHC_S_Power_Heating"];
    }
}

// --- Energy meter: select based on installationType ---
if (installationType == "cooling") {
    if (values["CHC_M_Energy_Cooling"] != null) {
        newValues["E_th_kWh"] = values["CHC_M_Energy_Cooling"];
    }
} else {
    if (values["CHC_M_Energy_Heating"] != null) {
        newValues["E_th_kWh"] = values["CHC_M_Energy_Heating"];
    }
}

// --- Volume meter ---
if (values["CHC_M_Volume"] != null) {
    newValues["V_m3"] = values["CHC_M_Volume"];
}

// --- Auxiliary temperature sensors (TS1/TS2 devices) ---
if (values["temperature"] != null) {
    if (deviceName.endsWith("_TS1")) {
        newValues["auxT1_C"] = values["temperature"];
    } else if (deviceName.endsWith("_TS2")) {
        newValues["auxT2_C"] = values["temperature"];
    } else {
        newValues["temperature"] = values["temperature"];
    }
}

// ============================================================
// Calculated Power: P = rho * cp * Vdot * dT
// ============================================================
if (calculatePower && newValues["Vdot_m3h"] != null && newValues["dT_K"] != null) {

    // Get reference temperature for density calculation (use T_flow, default 40°C)
    var refTemp = 40.0;
    if (newValues["T_flow_C"] != null) {
        refTemp = newValues["T_flow_C"];
    }

    // Calculate fluid properties based on fluidType
    // cp [kJ/(kg·K)], rho [kg/m³]
    var cp = 4.186;
    var rho = 1000.0;

    if (fluidType == "water") {
        // Water: cp nearly constant, rho temperature-dependent
        // rho(T) = 1000 - 0.4 * (T - 20) for T in °C
        cp = 4.186;
        rho = 1000.0 - 0.4 * (refTemp - 20.0);
        // Clamp rho to reasonable range
        if (rho < 950) { rho = 950; }
        if (rho > 1000) { rho = 1000; }
    } else if (fluidType == "glycol20") {
        // 20% Ethylene Glycol - fixed values at ~20°C
        cp = 3.87;
        rho = 1025.0;
    } else if (fluidType == "glycol30") {
        // 30% Ethylene Glycol - fixed values at ~20°C
        cp = 3.65;
        rho = 1040.0;
    } else if (fluidType == "glycol40") {
        // 40% Ethylene Glycol - fixed values at ~20°C
        cp = 3.45;
        rho = 1055.0;
    } else if (fluidType == "propyleneGlycol20") {
        // 20% Propylene Glycol - fixed values at ~20°C
        cp = 3.95;
        rho = 1020.0;
    } else if (fluidType == "propyleneGlycol30") {
        // 30% Propylene Glycol - fixed values at ~20°C
        cp = 3.75;
        rho = 1030.0;
    }

    // P [kW] = rho [kg/m³] * cp [kJ/(kg·K)] * Vdot [m³/h] * dT [K] / 3600 [s/h]
    // Simplified: P = (rho * cp / 3600) * Vdot * dT
    var factor = (rho * cp) / 3600.0;
    var P_calc = factor * newValues["Vdot_m3h"] * newValues["dT_K"];
    newValues["P_th_calc_kW"] = Math.round(P_calc * 1000) / 1000;

    // ============================================================
    // Power Deviation Detection (compare measured vs calculated)
    // ============================================================
    if (newValues["P_th_kW"] != null && newValues["P_th_calc_kW"] > 0) {
        // Calculate deviation percentage
        var deviation = ((newValues["P_th_kW"] - newValues["P_th_calc_kW"]) / newValues["P_th_calc_kW"]) * 100;
        newValues["P_deviation_pct"] = Math.round(deviation * 10) / 10;

        // Set P_sensor_flag based on absolute deviation
        var absDeviation = Math.abs(deviation);
        if (absDeviation < 10) {
            newValues["P_sensor_flag"] = "ok";
        } else if (absDeviation < 25) {
            newValues["P_sensor_flag"] = "warn";
        } else {
            newValues["P_sensor_flag"] = "error";
        }
    }
}

// ============================================================
// Derived Telemetry
// ============================================================

// --- is_on: System running if flow > threshold ---
if (newValues["Vdot_m3h"] != null) {
    newValues["is_on"] = newValues["Vdot_m3h"] > flowOnThreshold;
}

// --- load_class: low/mid/high based on power vs design ---
var loadClass = null;
if (newValues["P_th_kW"] != null && designPower != null && designPower > 0) {
    var loadPct = (newValues["P_th_kW"] / designPower) * 100;
    if (loadPct < 30) {
        loadClass = "low";
    } else if (loadPct < 60) {
        loadClass = "mid";
    } else {
        loadClass = "high";
    }
    newValues["load_class"] = loadClass;
}

// --- dT_flag: ok/warn/severe based on actual vs design delta-T ---
// Only evaluate at mid/high load (skip low load)
if (newValues["dT_K"] != null && designDeltaT != null && designDeltaT > 0) {
    // Only calculate if load_class is mid or high (or if we don't have load_class)
    var shouldEvaluate = (loadClass == null) || (loadClass == "mid") || (loadClass == "high");

    if (shouldEvaluate) {
        var dTRatio = newValues["dT_K"] / designDeltaT;
        if (dTRatio >= 0.8) {
            newValues["dT_flag"] = "ok";
        } else if (dTRatio >= 0.6) {
            newValues["dT_flag"] = "warn";
        } else {
            newValues["dT_flag"] = "severe";
        }
    }
}

// --- schedule_violation: running outside defined operating hours ---
// ROBUST: Only process if weeklySchedule exists and looks like valid JSON
var scheduleJson = metadata["ss_weeklySchedule"];
if (scheduleJson != null && scheduleJson != "" && scheduleJson != "null" && scheduleJson.startsWith("{")) {

    var schedule = JSON.parse(scheduleJson);

    if (schedule != null) {
        // Timezone offset in minutes (default: 60 = CET)
        // ROBUST: Handle missing or invalid timezoneOffset
        var tzOffset = 60;
        var tzVal = schedule["timezoneOffset"];
        if (tzVal != null && tzVal != "") {
            tzOffset = toInt(tzVal);
        }

        // Get timestamp
        var ts = msg["ts"];
        if (ts == null && metadata["ts"] != null) {
            ts = parseLong(metadata["ts"]);
        }

        if (ts != null && newValues["is_on"] != null) {

            // ============================================================
            // European DST Detection (CET/CEST) - Simplified
            // Using integer arithmetic to avoid Double/Integer cast issues
            // ============================================================
            var isDST = false;
            var msPerDay = 86400000;
            var msPerHour = 3600000;
            var days = toInt(ts / msPerDay);

            // Extract date components
            var z = days + 719468;
            var era = toInt(z / 146097);
            if (z < 0) { era = toInt((z - 146096) / 146097); }
            var doe = z - era * 146097;
            var yoe = toInt((doe - toInt(doe / 1460) + toInt(doe / 36524) - toInt(doe / 146096)) / 365);
            var year = yoe + era * 400;
            var doy = doe - (365 * yoe + toInt(yoe / 4) - toInt(yoe / 100));
            var mp = toInt((5 * doy + 2) / 153);
            var day = doy - toInt((153 * mp + 2) / 5) + 1;
            var month = mp + 3;
            if (mp >= 10) { month = mp - 9; }
            if (month <= 2) { year = year + 1; }

            // Determine DST status
            if (month > 3 && month < 10) {
                isDST = true;
            } else if (month == 3 || month == 10) {
                var y = year;
                var m = month;
                if (m <= 2) { y = y - 1; m = m + 12; }
                var firstOfMonth = 365 * y + toInt(y / 4) - toInt(y / 100) + toInt(y / 400) + toInt((153 * (m - 3) + 2) / 5) + 1 - 719469;
                var dowFirst = (firstOfMonth + 4) % 7;
                var dowLast = (dowFirst + 30) % 7;
                var lastSunday = 31 - dowLast;
                if (dowLast == 0) { lastSunday = 31; }
                var hourUTC = toInt((ts % msPerDay) / msPerHour);

                if (month == 3) {
                    if (day > lastSunday || (day == lastSunday && hourUTC >= 2)) {
                        isDST = true;
                    }
                } else {
                    if (day < lastSunday || (day == lastSunday && hourUTC < 3)) {
                        isDST = true;
                    }
                }
            }

            // Apply DST correction
            var effectiveOffset = tzOffset;
            if (isDST) { effectiveOffset = tzOffset + 60; }

            // Convert to local time
            var localTs = ts + effectiveOffset * 60000;

            // Day of week (0=Sun, 1=Mon, ... 6=Sat)
            var dayIndex = (toInt(localTs / msPerDay) + 4) % 7;

            // Get day name
            var dayName = "sunday";
            if (dayIndex == 1) { dayName = "monday"; }
            else if (dayIndex == 2) { dayName = "tuesday"; }
            else if (dayIndex == 3) { dayName = "wednesday"; }
            else if (dayIndex == 4) { dayName = "thursday"; }
            else if (dayIndex == 5) { dayName = "friday"; }
            else if (dayIndex == 6) { dayName = "saturday"; }

            // Current local time as minutes since midnight
            var msInDay = localTs % msPerDay;
            var currentMinutes = toInt(msInDay / 60000);

            // Check schedule for today
            // Supports TWO formats:
            // 1. Simple: {"monday": true, "tuesday": false, ...}
            // 2. Full:   {"monday": {"enabled": true, "start": "06:00", "end": "22:00"}, ...}
            var isWithinSchedule = false;
            var todayValue = schedule[dayName];

            if (todayValue != null) {
                // Convert to string to detect type (avoids type comparison errors)
                var todayStr = "" + todayValue;

                if (todayStr == "true") {
                    // Simple format: boolean true - always within schedule
                    isWithinSchedule = true;
                } else if (todayStr == "false") {
                    // Simple format: boolean false - never within schedule
                    isWithinSchedule = false;
                } else {
                    // Full format: todayValue is an object with enabled/start/end
                    var enabled = todayValue["enabled"];
                    var enabledStr = "" + enabled;
                    var isEnabled = (enabledStr == "true");

                    if (isEnabled) {
                        var startStr = todayValue["start"];
                        var endStr = todayValue["end"];

                        if (startStr != null && endStr != null) {
                            // Parse "HH:MM" to minutes
                            var startH = toInt(parseLong(startStr.substring(0, 2)));
                            var startM = toInt(parseLong(startStr.substring(3, 5)));
                            var startMinutes = startH * 60 + startM;

                            var endH = toInt(parseLong(endStr.substring(0, 2)));
                            var endM = toInt(parseLong(endStr.substring(3, 5)));
                            var endMinutes = endH * 60 + endM;

                            if (currentMinutes >= startMinutes && currentMinutes <= endMinutes) {
                                isWithinSchedule = true;
                            }
                        } else {
                            // No start/end defined but enabled - assume within schedule
                            isWithinSchedule = true;
                        }
                    }
                }
            }

            // Violation = system running outside scheduled operating hours
            if (newValues["is_on"] == true && !isWithinSchedule) {
                newValues["schedule_violation"] = true;
            } else {
                newValues["schedule_violation"] = false;
            }
        }
    }
}

// ============================================================
// Outlier Detection (only check if value exists)
// ============================================================

// Check Power
if (newValues["P_th_kW"] != null) {
    if (newValues["P_th_kW"] < 0 || newValues["P_th_kW"] > MAX_POWER_KW) {
        dataQuality = "error";
    }
}

// Check Calculated Power
if (newValues["P_th_calc_kW"] != null) {
    if (newValues["P_th_calc_kW"] < 0 || newValues["P_th_calc_kW"] > MAX_POWER_KW) {
        dataQuality = "error";
    }
}

// Check Energy (meter value should be positive)
if (newValues["E_th_kWh"] != null) {
    if (newValues["E_th_kWh"] < 0 || newValues["E_th_kWh"] > MAX_ENERGY_KWH) {
        dataQuality = "error";
    }
}

// Check Temperatures
if (newValues["T_flow_C"] != null) {
    if (newValues["T_flow_C"] < MIN_TEMP_C || newValues["T_flow_C"] > MAX_TEMP_C) {
        dataQuality = "error";
    }
}
if (newValues["T_return_C"] != null) {
    if (newValues["T_return_C"] < MIN_TEMP_C || newValues["T_return_C"] > MAX_TEMP_C) {
        dataQuality = "error";
    }
}
if (newValues["auxT1_C"] != null) {
    if (newValues["auxT1_C"] < MIN_TEMP_C || newValues["auxT1_C"] > MAX_TEMP_C) {
        dataQuality = "error";
    }
}
if (newValues["auxT2_C"] != null) {
    if (newValues["auxT2_C"] < MIN_TEMP_C || newValues["auxT2_C"] > MAX_TEMP_C) {
        dataQuality = "error";
    }
}

// Check Flow
if (newValues["Vdot_m3h"] != null) {
    if (newValues["Vdot_m3h"] < 0 || newValues["Vdot_m3h"] > MAX_FLOW_M3H) {
        dataQuality = "error";
    }
}

// ============================================================
// Set data_quality flag
// ============================================================
newValues["data_quality"] = dataQuality;

// ============================================================
// Build output message
// ============================================================
var newMsg = {};

// Preserve timestamp if present
if (msg["ts"] != null) {
    newMsg["ts"] = msg["ts"];
}

// Only output if we have at least one value (besides data_quality)
if (newValues.size() > 1) {
    newMsg["values"] = newValues;
    return {msg: newMsg, metadata: metadata, msgType: msgType};
} else {
    return {msg: {}, metadata: metadata, msgType: msgType};
}
