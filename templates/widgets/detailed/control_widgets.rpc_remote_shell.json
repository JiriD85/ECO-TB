{
  "fqn": "control_widgets.rpc_remote_shell",
  "name": "RPC remote shell",
  "deprecated": false,
  "image": "tb-image;/api/images/system/rpc_remote_shell_system_widget_image.png",
  "description": "Allows to emulate remote shell. Requires custom implementation on the target device to work correctly.",
  "descriptor": {
    "type": "rpc",
    "sizeX": 9.5,
    "sizeY": 5.5,
    "resources": [],
    "templateHtml": "<div style=\"height: 100%; overflow-y: auto;\" id=\"device-terminal\"></div>",
    "templateCss": ".cmd .cursor.blink {\n    -webkit-animation-name: terminal-underline;\n       -moz-animation-name: terminal-underline;\n        -ms-animation-name: terminal-underline;\n            animation-name: terminal-underline;\n}\n.terminal .inverted, .cmd .inverted {\n    border-bottom-color: #aaa;\n}\n",
    "controllerScript": "var requestTimeout = 500;\nvar commandStatusPollingInterval = 200;\n\nvar welcome = 'Welcome to ThingsBoard RPC remote shell.\\n';\n\nvar terminal, rpcEnabled, simulated, deviceName, cwd;\nvar commandExecuting = false;\n\nself.onInit = function() {\n    var subscription = self.ctx.defaultSubscription;\n    rpcEnabled = subscription.rpcEnabled;\n    if (subscription.targetEntityName && subscription.targetEntityName.length) {\n        deviceName = subscription.targetEntityName;\n    } else {\n        deviceName = 'Simulated';\n        simulated = true;\n    }\n    if (self.ctx.settings.requestTimeout) {\n        requestTimeout = self.ctx.settings.requestTimeout;\n    }\n\n    terminal = $('#device-terminal', self.ctx.$container).terminal(\n        function (command) {\n            if (command && command.trim().length) {\n                try {\n                    if (command.trim() === 'exit') {\n                        if (!simulated) {\n                            self.ctx.controlApi.sendTwoWayCommand('sendCommand', {\n                                command: 'exit',\n                                cwd: cwd\n                            }, requestTimeout).subscribe();\n                        }\n                        this.disable();\n                        return;\n                    }\n                    if (simulated) {\n                        this.echo(command);\n                    } else {\n                        sendCommand(this, command);\n                    }\n                } catch(e) {\n                    this.error(e + '');\n                }\n            } else {\n               this.echo('');\n            }\n        }, {\n            greetings: false,\n            enabled: rpcEnabled,\n            prompt: rpcEnabled ? currentPrompt : '',\n            name: 'shell',\n            pauseEvents: false,\n            keydown: function (e, term) {\n                if ((e.which == 67 || e.which == 68) && e.ctrlKey) { // CTRL+C || CTRL+D\n                    if (commandExecuting) {\n                        terminateCommand(term);\n                        return false;\n                    }\n                }\n            },\n            onInit: initTerm\n        }\n    );\n};\n\nfunction initTerm(terminal) {\n    terminal.echo(welcome);\n    if (!rpcEnabled) {\n        terminal.error('Target device is not set!\\n');\n    } else {\n        terminal.echo('Current target device for RPC terminal: [[b;#fff;]' + deviceName + ']\\n');\n        if (!simulated) {\n            terminal.pause();\n            getTermInfo(terminal, function (remoteTermInfo) {\n                if (remoteTermInfo) {\n                    terminal.echo('Remote platform info:');\n                    if (remoteTermInfo.platform) {\n                        terminal.echo('OS: [[b;#fff;]' + remoteTermInfo.platform + ']');\n                    } else {\n                        terminal.echo('OS: [[;#f00;]Unknown]');\n                    }\n                    if (remoteTermInfo.release) {\n                        terminal.echo('OS release: [[b;#fff;]' + remoteTermInfo.release + ']');\n                    } else {\n                        terminal.echo('OS release: [[;#f00;]Unknown]');\n                    }\n                    terminal.echo('\\r');\n                } else {\n                    terminal.echo('[[;#f00;]Unable to get remote platform info.\\nDevice is not responding.]\\n');\n                }\n                terminal.resume();\n            });\n        }\n    }\n}\n\nfunction currentPrompt(callback) {\n    if (cwd) {\n        callback('[[b;#2196f3;]' + deviceName + ']: [[b;#8bc34a;]' + cwd + ']> ');\n    } else {\n        callback('[[b;#8bc34a;]' + deviceName + ']> ');\n    }\n}\n\nfunction getTermInfo(terminal, callback) {\n    self.ctx.controlApi.sendTwoWayCommand('getTermInfo', null, requestTimeout).subscribe(\n        function(response) {\n            let termInfo;\n            if (typeof response === 'string') {\n                try {\n                    termInfo = JSON.parse(response);\n                } catch (e) {\n                    terminal.error('Error parsing response: ' + e);\n                    callback(null);\n                    return;\n                }\n            } else {\n                termInfo = response;\n            }\n            if (termInfo && termInfo.cwd) {\n                cwd = termInfo.cwd;\n            }\n            if (callback) {\n                callback(termInfo);\n            }\n        },\n        function() {\n            if (callback) {\n                callback(null);\n            }\n        }\n    );\n}\n\nfunction sendCommand(terminal, command) {\n    terminal.pause();\n    var sendCommandRequest = {\n        command: command,\n        cwd: cwd\n    };\n    self.ctx.controlApi.sendTwoWayCommand('sendCommand', sendCommandRequest, requestTimeout).subscribe(\n        function (responseBody) {\n            if (responseBody && responseBody.ok) {\n                commandExecuting = true;\n                setTimeout(pollCommandStatus.bind(null, terminal), commandStatusPollingInterval);\n            } else {\n                var error = responseBody ? responseBody.error : 'Unhandled error.';\n                terminal.error(error);\n                terminal.resume();\n            }\n        },\n        function () {\n            onRpcError(terminal);\n        }\n    );\n}\n\nfunction terminateCommand(terminal) {\n    self.ctx.controlApi.sendTwoWayCommand('terminateCommand', null, requestTimeout).subscribe(\n        function (responseBody) {\n            if (!responseBody.ok) {\n                commandExecuting = false;\n                terminal.error(responseBody.error);\n                terminal.resume();\n            }\n        },\n        function () {\n            onRpcError(terminal);\n        }\n    );\n}\n\nfunction onRpcError(terminal) {\n    var errorText = self.ctx.defaultSubscription.rpcErrorText;\n    terminal.error(errorText);\n    terminal.resume();\n}\n\nfunction pollCommandStatus(terminal) {\n    self.ctx.controlApi.sendTwoWayCommand('getCommandStatus', null, requestTimeout).subscribe(\n        function (commandStatusResponse) {\n            for (var i = 0; i < commandStatusResponse.data.length; i++) {\n                var dataElement = commandStatusResponse.data[i];\n                if (dataElement.stdout) {\n                    terminal.echo(dataElement.stdout);\n                }\n                if (dataElement.stderr) {\n                    terminal.error(dataElement.stderr);\n                }\n            }\n            if (commandStatusResponse.done) {\n                commandExecuting = false;\n                cwd = commandStatusResponse.cwd;\n                terminal.resume();\n            } else {\n                var interval = commandStatusPollingInterval;\n                if (!commandStatusResponse.data.length) {\n                    interval *= 5;\n                }\n                setTimeout(pollCommandStatus.bind(null, terminal), interval);\n            }\n        },\n        function () {\n            commandExecuting = false;\n            onRpcError(terminal);\n        }\n    );\n}\n\nself.onResize = function () {\n    if (terminal) {\n        terminal.resize(self.ctx.width, self.ctx.height);\n    }\n};\n\nself.onDestroy = function() {\n};",
    "settingsSchema": "",
    "dataKeySettingsSchema": "{}\n",
    "settingsDirective": "tb-rpc-shell-widget-settings",
    "defaultConfig": "{\"targetDeviceAliases\":[],\"showTitle\":true,\"backgroundColor\":\"#010101\",\"color\":\"rgba(255, 254, 254, 0.87)\",\"padding\":\"0px\",\"settings\":{\"parseGpioStatusFunction\":\"return body[pin] === true;\",\"gpioStatusChangeRequest\":{\"method\":\"setGpioStatus\",\"paramsBody\":\"{\\n   \\\"pin\\\": \\\"{$pin}\\\",\\n   \\\"enabled\\\": \\\"{$enabled}\\\"\\n}\"},\"requestTimeout\":500,\"switchPanelBackgroundColor\":\"#b71c1c\",\"gpioStatusRequest\":{\"method\":\"getGpioStatus\",\"paramsBody\":\"{}\"},\"gpioList\":[{\"pin\":1,\"label\":\"GPIO 1\",\"row\":0,\"col\":0,\"_uniqueKey\":0},{\"pin\":2,\"label\":\"GPIO 2\",\"row\":0,\"col\":1,\"_uniqueKey\":1},{\"pin\":3,\"label\":\"GPIO 3\",\"row\":1,\"col\":0,\"_uniqueKey\":2}]},\"title\":\"RPC remote shell\",\"dropShadow\":true,\"enableFullscreen\":true,\"widgetStyle\":{},\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400},\"useDashboardTimewindow\":true,\"showLegend\":false,\"actions\":{}}"
  },
  "externalId": null,
  "resources": null,
  "id": {
    "entityType": "WIDGET_TYPE",
    "id": "7aaabcf0-b418-11f0-b467-01a4a84a7779"
  },
  "createdTime": 1761667767871,
  "tenantId": {
    "entityType": "TENANT",
    "id": "13814000-1dd2-11b2-8080-808080808080"
  },
  "scada": false,
  "version": 1,
  "tags": [
    "command",
    "downlink",
    "device configuration",
    "device control",
    "invocation",
    "remote method",
    "remote function",
    "interface",
    "subroutine call",
    "inter-process communication",
    "server request"
  ]
}