---
phase: 03-timeseries-live
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - js library/ECO Project Wizard.js
autonomous: false

must_haves:
  truths:
    - "P-Flow devices show heating or cooling timeseries based on installationType"
    - "Temperature Sensors show temperature value with unit"
    - "Timeseries values update automatically every 5 seconds"
    - "Manual refresh button triggers immediate data update"
    - "Loading indicator shows during data fetch"
    - "Interval is cleared when dialog closes (no memory leak)"
  artifacts:
    - path: "js library/ECO Project Wizard.js"
      provides: "Timeseries fetching and live update logic"
      contains: "fetchDeviceTimeseries|getPFlowTimeseriesKeys|setInterval|clearInterval"
  key_links:
    - from: "MeasurementInfoDialogController"
      to: "/api/plugins/telemetry/DEVICE/{id}/values/timeseries"
      via: "widgetContext.http.get in fetchDeviceTimeseries"
      pattern: "http\\.get.*values/timeseries"
    - from: "vm.refreshInterval"
      to: "setInterval callback"
      via: "5000ms interval stored for cleanup"
      pattern: "setInterval.*5000"
    - from: "vm.cancel"
      to: "clearInterval"
      via: "cleanup on dialog close"
      pattern: "clearInterval.*refreshInterval"
---

<objective>
Add live timeseries data fetching and display to the Measurement Info dialog with 5-second auto-refresh.

Purpose: Enable users to see real-time telemetry values (power, energy, temperature, volume flow) for P-Flow and Temperature Sensor devices, automatically refreshing every 5 seconds.

Output: Extended openMeasurementInfoDialog with timeseries fetching, display, and auto-refresh capability.
</objective>

<execution_context>
@/Users/jiridockal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jiridockal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-timeseries-live/03-RESEARCH.md
@js library/ECO Project Wizard.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add timeseries fetching logic</name>
  <files>js library/ECO Project Wizard.js</files>
  <action>
Extend the `openMeasurementInfoDialog` function and `MeasurementInfoDialogController` with timeseries fetching capabilities.

**1. Add constants at the top of the MEASUREMENT INFO DIALOG section (before the HTML template):**

```javascript
// Timeseries key mappings
const TIMESERIES_UNITS = {
  'CHC_S_Heating_Power': 'kW',
  'CHS_M_Heating_Energy': 'kWh',
  'CHC_S_Cooling_Power': 'kW',
  'CHC_M_Cooling_Energy': 'kWh',
  'CHC_S_VolumeFlow': 'l/hr',
  'CHC_M_Volume': 'm\u00B3',
  'CHC_S_TemperatureDiff': '\u00B0C',
  'CHC_S_TemperatureFlow': '\u00B0C',
  'CHC_S_TemperatureReturn': '\u00B0C',
  'CHC_S_Velocity': 'm/s',
  'temperature': '\u00B0C'
};

const TIMESERIES_LABELS = {
  'CHC_S_Heating_Power': 'Heating Power',
  'CHS_M_Heating_Energy': 'Heating Energy',
  'CHC_S_Cooling_Power': 'Cooling Power',
  'CHC_M_Cooling_Energy': 'Cooling Energy',
  'CHC_S_VolumeFlow': 'Volume Flow',
  'CHC_M_Volume': 'Volume',
  'CHC_S_TemperatureDiff': 'Temp Diff',
  'CHC_S_TemperatureFlow': 'Flow Temp',
  'CHC_S_TemperatureReturn': 'Return Temp',
  'CHC_S_Velocity': 'Velocity',
  'temperature': 'Temperature'
};
```

**2. Add helper functions inside `openMeasurementInfoDialog` (after `findDeviceKit` function, before `fetchAttributes`):**

```javascript
function getPFlowTimeseriesKeys(installationType) {
  var commonKeys = [
    'CHC_S_VolumeFlow',
    'CHC_M_Volume',
    'CHC_S_TemperatureDiff',
    'CHC_S_TemperatureFlow',
    'CHC_S_TemperatureReturn',
    'CHC_S_Velocity'
  ];
  if (installationType === 'heating') {
    return ['CHC_S_Heating_Power', 'CHS_M_Heating_Energy'].concat(commonKeys);
  } else if (installationType === 'cooling') {
    return ['CHC_S_Cooling_Power', 'CHC_M_Cooling_Energy'].concat(commonKeys);
  }
  return commonKeys;
}

function fetchDeviceTimeseries(deviceId, keys) {
  return new Promise(function(resolve) {
    var keysParam = keys.join(',');
    var url = '/api/plugins/telemetry/DEVICE/' + deviceId.id + '/values/timeseries?keys=' + keysParam;
    widgetContext.http.get(url).subscribe(
      function(response) { resolve(response || {}); },
      function() { resolve({}); }
    );
  });
}

function formatTimeseriesValue(key, value) {
  if (value === null || value === undefined) return '-';
  var numValue = Number(value);
  if (!Number.isFinite(numValue)) return '-';
  var unit = TIMESERIES_UNITS[key] || '';
  var decimals = (key === 'CHC_M_Volume' || key.includes('Energy')) ? 3 : 2;
  return numValue.toFixed(decimals) + ' ' + unit;
}

function processTimeseriesResponse(response, keys) {
  var result = [];
  keys.forEach(function(key) {
    if (response && response[key] && response[key].length > 0) {
      result.push({
        key: key,
        label: TIMESERIES_LABELS[key] || key,
        value: response[key][0].value,
        formattedValue: formatTimeseriesValue(key, response[key][0].value)
      });
    }
  });
  return result;
}
```

**3. Update MeasurementInfoDialogController (extend the existing controller) to add:**

Add these variables after existing vm assignments:
```javascript
vm.isRefreshing = false;
vm.refreshInterval = null;
vm.lastRefresh = null;
vm.allDevices = [];
```

Add a `fetchAllTimeseries` function inside the controller:
```javascript
function fetchAllTimeseries() {
  if (vm.isRefreshing) return;
  vm.isRefreshing = true;

  var allDevices = [];
  vm.kitGroups.forEach(function(kit) {
    kit.devices.forEach(function(d) { allDevices.push(d); });
  });
  vm.noKitDevices.forEach(function(d) { allDevices.push(d); });

  var pflowDevices = allDevices.filter(function(d) { return d.type === 'P-Flow D116'; });
  var tempSensors = allDevices.filter(function(d) { return d.type === 'Temperature Sensor'; });
  var pflowKeys = getPFlowTimeseriesKeys(vm.installationType);

  var fetchPromises = [];

  pflowDevices.forEach(function(device) {
    fetchPromises.push(
      fetchDeviceTimeseries(device.id, pflowKeys).then(function(data) {
        device.timeseries = processTimeseriesResponse(data, pflowKeys);
      })
    );
  });

  tempSensors.forEach(function(device) {
    fetchPromises.push(
      fetchDeviceTimeseries(device.id, ['temperature']).then(function(data) {
        device.timeseries = processTimeseriesResponse(data, ['temperature']);
      })
    );
  });

  if (fetchPromises.length === 0) {
    vm.isRefreshing = false;
    return;
  }

  Promise.all(fetchPromises).then(function() {
    vm.isRefreshing = false;
    vm.lastRefresh = new Date();
  }).catch(function() {
    vm.isRefreshing = false;
  });
}
```

**4. Add refresh method and auto-refresh setup:**

```javascript
vm.refresh = function() {
  fetchAllTimeseries();
};

// Initial fetch and start auto-refresh
fetchAllTimeseries();
vm.refreshInterval = setInterval(function() {
  fetchAllTimeseries();
}, 5000);
```

**5. Update vm.cancel to cleanup interval:**

Replace existing vm.cancel with:
```javascript
vm.cancel = function() {
  if (vm.refreshInterval) {
    clearInterval(vm.refreshInterval);
    vm.refreshInterval = null;
  }
  vm.dialogRef.close(null);
  if (callback) {
    callback();
  }
};
```

**IMPORTANT:** Store `widgetContext` reference in a local variable at the start of `openMeasurementInfoDialog` so it can be accessed by the helper functions (it's already passed as parameter).
  </action>
  <verify>
Search for "fetchDeviceTimeseries" and "setInterval" in the file to confirm they exist:
```bash
grep -n "fetchDeviceTimeseries\|setInterval\|clearInterval\|TIMESERIES_UNITS" "js library/ECO Project Wizard.js"
```
All patterns should be found in the Measurement Info Dialog section.
  </verify>
  <done>
- TIMESERIES_UNITS and TIMESERIES_LABELS constants defined
- getPFlowTimeseriesKeys function returns correct keys based on installationType
- fetchDeviceTimeseries function makes REST API call to /api/plugins/telemetry endpoint
- processTimeseriesResponse extracts latest values with labels and formatted values
- fetchAllTimeseries filters devices by type and fetches appropriate timeseries
- vm.refresh triggers manual refresh
- setInterval starts 5-second auto-refresh
- clearInterval in vm.cancel prevents memory leak
  </done>
</task>

<task type="auto">
  <name>Task 2: Update HTML template for timeseries display</name>
  <files>js library/ECO Project Wizard.js</files>
  <action>
Update the `measurementInfoHtmlTemplate` and `measurementInfoCss` to display timeseries data and add refresh controls.

**1. Add refresh button to toolbar (after the title h2, before the flex-1 span):**

In the mat-toolbar section, add a refresh button:
```html
<button mat-icon-button (click)="refresh()" [disabled]="isRefreshing"
        type="button" title="Refresh data" style="margin-left: 8px;">
  <mat-icon [class.spinning]="isRefreshing">refresh</mat-icon>
</button>
```

The toolbar should now have: info icon, title, refresh button, flex-1 span, close button.

**2. Update mat-progress-bar to show during refresh:**

Change the progress bar condition from `*ngIf="isLoading"` to `*ngIf="isLoading || isRefreshing"`:
```html
<mat-progress-bar color="warn" mode="indeterminate" *ngIf="isLoading || isRefreshing"></mat-progress-bar>
<div style="height: 4px;" *ngIf="!isLoading && !isRefreshing"></div>
```

**3. Add timeseries section inside each device-item div:**

After the activity status and timestamp row (the div with `margin-left: 22px; margin-top: 6px;`), add the timeseries display. Add this INSIDE each device-item div, after the existing content:

```html
<!-- Timeseries Data -->
<div *ngIf="device.timeseries && device.timeseries.length > 0"
     style="margin-left: 22px; margin-top: 8px; padding: 8px; background: #f0f8ff; border-radius: 4px; border-left: 3px solid #305680;">
  <div *ngFor="let ts of device.timeseries" class="flex items-center gap-2" style="font-size: 11px; margin-bottom: 4px;">
    <span style="color: #666; min-width: 90px;">{{ ts.label }}:</span>
    <span style="font-weight: 600; color: #305680;">{{ ts.formattedValue }}</span>
  </div>
</div>
```

This timeseries section must appear in BOTH places:
- Inside the kit group device items (around line ~2258)
- Inside the noKitDevices device items (around line ~2293)

**4. Add last refresh indicator before the footer:**

Add just before the closing `</div>` of `mat-dialog-content`:
```html
<!-- Last Refresh Indicator -->
<div *ngIf="lastRefresh" style="text-align: right; font-size: 10px; color: #999; margin-top: 8px;">
  Last updated: {{ formatTimestampDE(lastRefresh.getTime()) }}
</div>
```

**5. Update CSS to add spinning animation:**

Add to `measurementInfoCss`:
```css
@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}
.measurement-info-dialog .spinning {
  animation: spin 1s linear infinite;
}
.measurement-info-dialog .timeseries-section div:last-child {
  margin-bottom: 0;
}
```
  </action>
  <verify>
Search for the new HTML elements and CSS:
```bash
grep -n "refresh\|spinning\|timeseries\|lastRefresh" "js library/ECO Project Wizard.js" | head -30
```
Should find: refresh button, spinning class, timeseries section, lastRefresh indicator.
  </verify>
  <done>
- Refresh button in toolbar with spinning icon during refresh
- Progress bar shows during both initial load and refresh
- Timeseries data displayed under each device with labels and values
- Last refresh timestamp shown at bottom of dialog
- Spinning animation CSS for refresh icon
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Live timeseries data display with 5-second auto-refresh in the Measurement Info dialog:
- P-Flow devices show power, energy, volume flow, temperatures, velocity
- Temperature Sensors show temperature value
- Refresh button in toolbar triggers manual update
- Loading indicator during data fetch
- Interval cleanup on dialog close
  </what-built>
  <how-to-verify>
1. Sync the JS library to ThingsBoard:
   ```bash
   cd /Users/jiridockal/development/ECO-TB && node sync/sync.js sync --js
   ```

2. Open ThingsBoard Measurements dashboard

3. Navigate to Measurements_card state

4. Click the info icon on a measurement row that has:
   - A P-Flow D116 device (with heating or cooling installationType)
   - Optionally a Temperature Sensor

5. Verify the dialog shows:
   - **Timeseries values** under each P-Flow device (power, energy, volume flow, temps)
   - **Temperature value** under Temperature Sensors (if present)
   - **Refresh button** (circular arrow) in the toolbar
   - **Loading bar** appears briefly during data fetch

6. Wait 5 seconds and verify:
   - Values refresh automatically (loading bar flashes)
   - "Last updated" timestamp changes at the bottom

7. Click the **Refresh button** and verify:
   - Immediate data refresh
   - Icon spins during refresh
   - Button disabled while refreshing

8. Close and reopen the dialog:
   - No console errors after close (interval was cleared)
   - Fresh data loads on reopen
  </how-to-verify>
  <resume-signal>Type "approved" if timeseries display and auto-refresh work correctly, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. Grep for key patterns confirms all timeseries logic exists
2. User verification confirms live data display works
3. No memory leak from orphaned intervals (verified by closing dialog)
4. Requirements TS-01 through TS-04, LIVE-01 through LIVE-03 satisfied
</verification>

<success_criteria>
- P-Flow Heating: CHC_S_Heating_Power and CHS_M_Heating_Energy display with units
- P-Flow Cooling: CHC_S_Cooling_Power and CHC_M_Cooling_Energy display with units
- P-Flow Common: VolumeFlow, Volume, TemperatureDiff, TempFlow, TempReturn, Velocity display
- Temperature Sensor: temperature displays with degree C unit
- Auto-refresh fires every 5 seconds
- Manual refresh button works
- Loading indicator visible during fetch
- No console errors after dialog close
</success_criteria>

<output>
After completion, create `.planning/phases/03-timeseries-live/03-01-SUMMARY.md`
</output>
